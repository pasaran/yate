# Типы данных и преобразование типов

В yate есть 4 базовых типов данных:
  * `nodeset` - выборка JSON-данных
  * `scalar` - примитивы, строка или число.
  * `boolean` - булен
  * `xml` - Всегда строка. Данные, готовые для вставки в HTML-результат. Главное отличие `xml` от `scalar` в эскейпинге HTML-спецсимолов. Но оно производится не при вставке в HTML, а при преобразование типов.

## Типичные преобразования

### nodeset2scalar
Преобразование выборки данных в строку.
Работает следующим образом:
  1. Если пустая выборка - возвращается пустая строка
  2. Берем первый элемент выборки
  3. Если первый элемент - объект (массив), то возвращаем пустую строку, иначе возвращаем значение.

### nodeset2xml
Преобразование данных в строку. По сути является двойным преобразованием `nodeset2scalar` -> `scalar2xml`.
Главной особенностью является эскейпинг символов (`&` -> `&amp;`, `<` -> `&lt;`, `>` -> `&gt;`)
```
match / {
    <div>
        .foo
    </div>
}
```

После компиляции вывод будет состоять из:
```js
r0 += "<div>";
r0 += nodeset2xml( .foo );
r0 += "</div>";
```

## Правильные рецепты

### apply vs func

Результат `apply` всегда возвращает тип `xml`, т.е. эскейпленную строку.
Поэтому, если шаблон нужен только для удоства обработки данных, а не для вывода, то его стоит переписать на функцию.
Это поможет избежать проблем с излишними или ненужными преобразованиями.

Плохой пример:
```
external scalar tst(scalar)

match / {
    foo = apply / name
    <div>
        tst(foo)
    </div>
}

match / name {
    if (.title) {
        .title
    } else {
        "no title"
    }
}

```

Почему это плохой пример?
`apply / name` вернет **уже эскейпленную строку**, поэтому если вы передаете `foo` в external-функцию, то данные **придется преобразовывать еще раз**.
```
v0 = apply / name;
r0 += scalar2xml( (yr.externals['tst'])(/* деэскейпим строку */xml2scalar( v0 )) );
```


Хороший пример:
```
external scalar tst(scalar)

match / {
    foo = getName(/)
    <div>
        tst(foo)
    </div>
}

func getName(node) {
    if (node.title) {
        node.title
    } else {
        "no title"
    }
}
```

В этом случае, `getName` будет возвращать `scalar`, т.е. чистые, не преобразованные данные.
```js
var v1 = getName(/)
r0 += scalar2xml( (yr.externals['tst'])(v1) );
```

### external scalar func-name(scalar)

Для простых преобразований строковых данных объявлять функцию стоит как `external scalar func-name(scalar)`.
В этом случае вам в агрументах приходят чистые данные, которые на выходе преобразовываются в `xml` средствами yate и безопасно вставляются в HTML.

```js
r0 += scalar2xml( (yr.externals['func-name'])(v1) );
```
